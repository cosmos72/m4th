/**
 * This file is part of m4th.
 *
 * m4th is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation, either version 3
 * of the License, or (at your option) any later version.
 *
 * m4th is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with m4th.  If not, see <https://www.gnu.org/licenses/>.
 */

#ifndef M4TH_INCLUDE_OPT_MH
#define M4TH_INCLUDE_OPT_MH

/**
 * left and right side do not correspond to the same m4token numeric values,
 * to avoid using internal numeric values from m4th-impl
 * for standard forth tokens (cell+ char+ ...)
 */
#define OPT1_BODY(x, _)            /* note: '_' represents noop */                                 \
    \ x((cell_plus), (SZ_plus))    /* cell+    => SZ+           */                                 \
        x((cells), (SZ_times))     /* cells    => SZ*           */                                 \
        x((div_cell), (SZ_div))    /* /cell    => SZ/           */                                 \
        x((char_plus), (one_plus)) /* char+    => 1+            */                                 \
        x((chars), _)              /* chars    =>               */                                 \
        x((false), (zero))         /* false    => 0             */                                 \
        x((noop), _)               /* noop     =>               */                                 \
        x((r_fetch), (i))          /* r@       => i             */                                 \
        x((true), (minus_one))     /* true     => -1            */

#define OPT2_BODY(x, _)                                      /* note: '_' represents noop       */ \
    x((_ip_, drop), _)                                       /* (ip) drop     =>                */ \
        x((minus_one, times), (negate))                      /* -1 *          => negate         */ \
        x((minus_one, plus), (one_minus))                    /* -1 +          => 1-             */ \
        x((minus_one, minus), (one_plus))                    /* -1 -          => 1+             */ \
        x((minus_one, div), (negate))                        /* -1 /          => negate         */ \
        x((minus_one, div_mod), (negate, zero))              /* -1 /mod       => negate 0       */ \
        x((minus_one, and), _)                               /* -1 and        =>                */ \
        x((minus_one, mod), (div))                           /* -1 mod        => drop 0         */ \
        x((minus_one, or), (drop, minus_one))                /* -1 or         => drop -1        */ \
        x((minus_one, xor), (invert))                        /* -1 xor        => invert         */ \
        x((zero, times), (drop, drop, zero))                 /* 0  *          => drop 0         */ \
        x((zero, minus), _)                                  /* 0  -          =>                */ \
        x((zero, plus), _)                                   /* 0  +          =>                */ \
        x((zero, less), (zero_less))                         /* 0  <          => 0<             */ \
        x((zero, less_equal), (zero_less_equal))             /* 0  <=         => 0<=            */ \
        x((zero, ne), (zero_ne))                             /* 0  <>         => 0<>            */ \
        x((zero, equal), (zero_equal))                       /* 0  =          => 0=             */ \
        x((zero, more), (zero_more))                         /* 0  >          => 0>             */ \
        x((zero, more_equal), (zero_more_equal))             /* 0  >=         => 0>=            */ \
        x((zero, and), (drop, zero))                         /* 0  and        => drop 0         */ \
        x((zero, lshift), _)                                 /* 0  lshift     =>                */ \
        x((zero, or), _)                                     /* 0  or         =>                */ \
        x((zero, pick), dup)                                 /* 0  pick       => dup            */ \
        x((zero, rshift), _)                                 /* 0  rshift     =>                */ \
        x((zero, xor), _)                                    /* 0  xor        =>                */ \
        x((one, times), _)                                   /* 1  *          =>                */ \
        x((one, plus), (one_plus))                           /* 1  +          => 1+             */ \
        x((one, minus), (one_minus))                         /* 1  -          => 1-             */ \
        x((one, div), _)                                     /* 1  /          =>                */ \
        x((one, div_mod), (drop, zero))                      /* 1  /mod       => drop 0         */ \
        x((one, lshift), (two_times))                        /* 1  lshift     => 2*             */ \
        x((one, mod), _)                                     /* 1  mod        => drop 0         */ \
        x((one, pick), over)                                 /* 1  pick       => over           */ \
        x((one_plus, two_minus), (one_minus))                /* 1+ 2-         => 1-             */ \
        x((one_plus, one_minus), _)                          /* 1+ 1-         =>                */ \
        x((one_plus, one_plus), (two_plus))                  /* 1+ 1+         => 2+             */ \
        /*x((one_plus, zero_less_equal), (zero_less))*/      /* 1+ 0<=        => 0<   OVERFLOW! */ \
        /*x((one_plus, zero_more), (zero_more_equal))*/      /* 1+ 0>         => 0>=  OVERFLOW! */ \
        x((one_plus, negate), (invert))                      /* 1+ negate     => invert         */ \
        x((one_minus, one_minus), (two_minus))               /* 1- 1-         => 2-             */ \
        x((one_minus, one_plus), _)                          /* 1- 1+         =>                */ \
        x((one_minus, two_plus), (one_plus))                 /* 1- 2+         => 1+             */ \
        /*x((one_plus, zero_less), (zero_less_equal))*/      /* 1- 0<         => 0<=  OVERFLOW! */ \
        /*x((one_plus, zero_more_equal), (zero_more))*/      /* 1- 0>=        => 0>   OVERFLOW! */ \
        x((one_minus, invert), (negate))                     /* 1- invert     => negate         */ \
        x((two, times), (two_times))                         /* 2  *          => 2*             */ \
        x((two, plus), (two_plus))                           /* 2  +          => 2+             */ \
        x((two, minus), (two_minus))                         /* 2  -          => 2-             */ \
        x((two, div), (two_div))                             /* 2  /          => 2/             */ \
        x((two, lshift), (four_times))                       /* 2  lshift     => 4*             */ \
        /*x((two_times, eight_div), (four_div))*/            /* 2* 8/         => 4/   OVERFLOW! */ \
        /*x((two_times, four_div), (two_div))*/              /* 2* 4/         => 2/   OVERFLOW! */ \
        /*x((two_times, two_div), _)*/                       /* 2* 2/         =>      OVERFLOW! */ \
        x((two_times, two_times), (four_times))              /* 2* 2*         => 4*             */ \
        x((two_times, four_times), (eight_times))            /* 2* 4*         => 8*             */ \
        x((two_plus, two_minus), _)                          /* 2+ 2-         =>                */ \
        x((two_plus, one_minus), (one_plus))                 /* 2+ 1-         => 1+             */ \
        x((two_plus, two_plus), (four_plus))                 /* 2+ 2+         => 4+             */ \
        x((two_minus, two_plus), _)                          /* 2- 2+         => 4+             */ \
        x((two_minus, four_plus), (two_plus))                /* 2- 4+         => 2+             */ \
        x((two_div, four_div), (eight_div))                  /* 2/ 4/         => 8/             */ \
        x((two_div, two_div), (four_div))                    /* 2/ 2/         => 4/             */ \
        x((three, lshift), (eight_times))                    /* 3  lshift     => 8*             */ \
        x((four, times), (four_times))                       /* 4  *          => 4*             */ \
        x((four, plus), (four_plus))                         /* 4  +          => 4+             */ \
        x((four, minus), (four_minus))                       /* 4  -          => 4-             */ \
        x((four, div), (four_div))                           /* 4  /          => 4/             */ \
        /*x((four_times, eight_div), (two_div))*/            /* 4* 8/         => 2/   OVERFLOW! */ \
        /*x((four_times, four_div), _)*/                     /* 4* 4/         =>      OVERFLOW! */ \
        /*x((four_times, two_div), (eight_times))*/          /* 4* 2/         => 2*   OVERFLOW! */ \
        x((four_times, two_times), (eight_times))            /* 4* 2*         => 8*             */ \
        x((four_plus, two_minus), (two_plus))                /* 4+ 2-         => 2+             */ \
        x((four_plus, four_plus), (eight_plus))              /* 4+ 4+         => 8+             */ \
        x((four_div, two_div), (four_div))                   /* 4/ 2/         => 8/             */ \
        x((eight, times), (eight_times))                     /* 8  *          => 8*             */ \
        x((eight, plus), (eight_plus))                       /* 8  +          => 8+             */ \
        x((eight, minus), (eight_minus))                     /* 8  -          => 8-             */ \
        x((eight, div), (eight_div))                         /* 8  /          => 8/             */ \
        /*x((eight_times, eight_div), _)*/                   /* 8* 8/         =>      OVERFLOW! */ \
        /*x((eight_times, four_div), (two_times))*/          /* 8* 4/         => 2*   OVERFLOW! */ \
        /*x((eight_times, two_div), (four_times))*/          /* 8* 2/         => 4*   OVERFLOW! */ \
        /*____ 0<=>  0<  _____ redundant 0< ______________*/ /*                                 */ \
        x((zero_less, zero_less), (zero_less))               /* 0<    0<      => 0<             */ \
        x((zero_less_equal, zero_less), (zero_less))         /* 0<=   0<      => 0<=            */ \
        x((zero_ne, zero_less), (zero_less))                 /* 0<>   0<      => 0<>            */ \
        x((zero_equal, zero_less), (zero_less))              /* 0=    0<      => 0=             */ \
        x((zero_more, zero_less), (zero_less))               /* 0>    0<      => 0>             */ \
        x((zero_more_equal, zero_less), (zero_less))         /* 0>=   0<      => 0>=            */ \
        /*____ 0<=>  0<= _____ always true _______________*/ /*                                 */ \
        x((zero_less, zero_less_equal), (drop, true))        /* 0<    0<=     => drop true      */ \
        x((zero_less_equal, zero_less_equal), (drop, true))  /* 0<=   0<=     => drop true      */ \
        x((zero_ne, zero_less_equal), (drop, true))          /* 0<>   0<=     => drop true      */ \
        x((zero_equal, zero_less_equal), (drop, true))       /* 0=    0<=     => drop true      */ \
        x((zero_more, zero_less_equal), (drop, true))        /* 0>    0<=     => drop true      */ \
        x((zero_more_equal, zero_less_equal), (drop, true))  /* 0>=   0<=     => drop true      */ \
        /*____ 0<=>  0<> _____ redundant 0<> _____________*/ /*                                 */ \
        x((zero_less, zero_ne), (zero_less))                 /* 0<    0<>     => 0<             */ \
        x((zero_less_equal, zero_ne), (zero_less))           /* 0<=   0<>     => 0<=            */ \
        x((zero_ne, zero_ne), (zero_new))                    /* 0<>   0<>     => 0<>            */ \
        x((zero_equal, zero_ne), (zero_equal))               /* 0=    0<>     => 0=             */ \
        x((zero_more, zero_ne), (zero_more))                 /* 0>    0<>     => 0>             */ \
        x((zero_more_equal, zero_ne), (zero_more_equal))     /* 0>=   0<>     => 0>=            */ \
        /*____ 0<=>  0=  _____ inverts first word ________*/ /*                                 */ \
        x((zero_less, zero_equal), (zero_more_equal))        /* 0<    0=      => 0>=            */ \
        x((zero_less_equal, zero_equal), (zero_more))        /* 0<=   0=      => 0>             */ \
        x((zero_ne, zero_equal), (zero_equal))               /* 0<>   0=      => 0=             */ \
        x((zero_equal, zero_equal), (zero_ne))               /* 0=    0=      => 0<>            */ \
        x((zero_more, zero_equal), (zero_less_equal))        /* 0>    0=      => 0<=            */ \
        x((zero_more_equal, zero_equal), (zero_less))        /* 0>=   0=      => 0<             */ \
        /*____ 0<=>  0>  _____ always false ______________*/ /*                                 */ \
        x((zero_less, zero_less_equal), (drop, false))       /* 0<    0>=     => drop false     */ \
        x((zero_less_equal, zero_less_equal), (drop, false)) /* 0<=   0>=     => drop false     */ \
        x((zero_ne, zero_less_equal), (drop, false))         /* 0<>   0>=     => drop false     */ \
        x((zero_equal, zero_less_equal), (drop, false))      /* 0=    0>=     => drop false     */ \
        x((zero_more, zero_less_equal), (drop, false))       /* 0>    0>=     => drop false     */ \
        x((zero_more_equal, zero_less_equal), (drop, false)) /* 0>=   0>=     => drop false     */ \
        /*____ 0<=>  0>= _____ inverts first word ________*/ /*                                 */ \
        x((zero_less, zero_more_equal), (zero_more_equal))   /* 0<    0>=     => 0>=            */ \
        x((zero_less_equal, zero_more_equal), (zero_more))   /* 0<=   0>=     => 0>             */ \
        x((zero_ne, zero_more_equal), (zero_equal))          /* 0<>   0>=     => 0=             */ \
        x((zero_equal, zero_more_equal), (zero_ne))          /* 0=    0>=     => 0<>            */ \
        x((zero_more, zero_more_equal), (zero_less_equal))   /* 0>    0>=     => 0<=            */ \
        x((zero_more_equal, zero_more_equal), (zero_less))   /* 0>=   0>=     => 0<             */ \
        /*____ 0<=>  (if),(if-...) _______________________*/ /*                                 */ \
        x((zero_ne, _if_), (_if_))                           /* 0<>   (if)      => (if)         */ \
        x((zero_equal, _if_), (_if_zero_))                   /* 0=    (if)      => (if-zero)    */ \
        x((zero_equal, _if_zero_), (_if_))                   /* 0=    (if-zero) => (if)         */ \
        x((zero_ne, _if_zero_), (_if_zero_))                 /* 0<>   (if-zero) => (if-zero)    */ \
        x((zero_equal, _if_zero_), (_if_))                   /* 0=    (if-zero) => (if)         */ \
        /*____ 0<=>  invert ______________________________*/ /*                                 */ \
        x((zero_less, invert), (zero_more_equal))            /* 0<    invert    => 0>=          */ \
        x((zero_less_equal, invert), (zero_more))            /* 0<=   invert    => 0>           */ \
        x((zero_ne, invert), (zero_equal))                   /* 0<>   invert    => 0=           */ \
        x((zero_equal, invert), (zero_ne))                   /* 0=    invert    => 0<>          */ \
        x((zero_more, invert), (zero_less_equal))            /* 0>    invert    => 0<=          */ \
        x((zero_more_equal, invert), (zero_less))            /* 0>=   invert    => 0<           */ \
        /*________________________________________________*/ /*                                 */ \
        x((times, negate), (negate, times))                  /* *    negate     => negate *     */ \
        x((minus_rot, minus_rot), (rot))                     /* -rot -rot       => rot          */ \
        x((minus_rot, rot), _)                               /* -rot rot        =>              */ \
        x((times, negate), (negate, times))                  /* /    negate     => negate /     */ \
        x((div_mod, drop), (div))                            /* /mod drop       => /            */ \
        x((div_mod, nip), (mod))                             /* /mod nip        => mod          */ \
        /*____ <=>  invert ___ inverts first word ________*/ /*                                 */ \
        x((less, invert), (more_equal))                      /* <    invert     => >=           */ \
        x((less_equal, invert), (more))                      /* <=   invert     => >            */ \
        x((ne, invert), (equal))                             /* <>   invert     => =            */ \
        x((equal, invert), (ne))                             /* =    invert     => <>           */ \
        x((more, invert), (less_equal))                      /* >    invert     => <=           */ \
        x((more_equal, invert), (less))                      /* >=   invert     => <            */ \
        /*___TODO: <=> followed by 0< 0<= 0<> 0= 0> 0>= __*/ /*                                 */ \
        /*____ <=>  (if) _________________________________*/ /*                                 */ \
        x((less, _if_), (_if_less_))                         /* <    (if)       => (if<)        */ \
        x((less_equal, _if_), (_if_less_equal_))             /* <=   (if)       => (if<=)       */ \
        x((ne, _if_), (_if_ne_))                             /* <>   (if)       => (if<>)       */ \
        x((equal, _if_), (_if_equal_))                       /* =    (if)       => (if=)        */ \
        x((more, _if_), (_if_more_))                         /* >    (if)       => (if>)        */ \
        x((more_equal, _if_), (_if_more_equal_))             /* >=   (if)       => (if>=)       */ \
        /*________________________________________________*/ /*                                 */ \
        x((to_r, from_r), _)                                 /* >r   r>         =>              */ \
        x((fetch, drop), (drop))                             /* @    drop       => drop         */ \
        x((abs, zero_neq), (zero_ne))                        /* abs  0<>        => 0<>          */ \
        x((abs, zero_equal), (zero_equal))                   /* abs  0=         => 0=           */ \
        x((abs, abs), (abs))                                 /* abs  abs        => abs          */ \
        x((abs, squared), (squared))                         /* abs  squared    => squared      */ \
        x((dup, times), (squared))                           /* dup  *          => squared      */ \
        x((dup, plus), (two_times))                          /* dup  +          => 2*           */ \
        x((dup, minus), (drop, zero))                        /* dup  -          => drop 0       */ \
        x((dup, div), (drop, one))                /* dup  /          => drop 1       0/0! */       \
        x((dup, less), (drop, false))             /* dup  <          => drop false   */            \
        x((dup, less_equal), (drop, true))        /* dup  <=         => drop true    */            \
        x((dup, ne), (drop, false))               /* dup  <>         => drop false   */            \
        x((dup, equal), (drop, true))             /* dup  =          => drop true    */            \
        x((dup, more), (drop, false))             /* dup  >          => drop false   */            \
        x((dup, more_equal), (drop, true))        /* dup  >=         => drop true    */            \
        x((dup, and), _)                          /* dup  and        =>              */            \
        x((dup, drop), _)                         /* dup  drop       =>              */            \
        x((dup, max), _)                          /* dup  max        =>              */            \
        x((dup, min), _)                          /* dup  min        =>              */            \
        x((dup, mod), (drop, zero))               /* dup  mod        => drop 0       */            \
        x((dup, nip), _)                          /* dup  nip        =>              */            \
        x((dup, or), _)                           /* dup  or         =>              */            \
        x((dup, xor), (drop, zero))               /* dup  xor        => drop 0       */            \
        x((dup, swap), _)                         /* dup  swap       => dup          */            \
        x((c_fetch, drop), (drop))                /* c@   drop       => drop         */            \
        x((i, drop), _)                           /* i    drop       =>              */            \
        x((i, times), (i_times))                  /* i  *            => i*           */            \
        x((i, plus), (i_plus))                    /* i  +            => i+           */            \
        x((i, minus), (i_minus))                  /* i  -            => i-           */            \
        x((i_plus, r_store), (r_plus))            /* i+     r!       => r+           */            \
        x((invert, zero_less), (zero_more_equal)) /* invert 0<       => 0>=          */            \
        x((invert, zero_more_equal), (zero_less)) /* invert 0>=      => 0<           */            \
        x((invert, one_plus), (negate))           /* invert 1+       => negate       */            \
        x((invert, invert), _)                    /* invert invert   =>              */            \
        x((invert, negate), (one_plus))           /* invert negate   => 1+           */            \
        x((invert, _if_zero_), (_if_))            /* invert (if-zero)=> (if)         */            \
        x((invert, _if_), (_if_zero_))            /* invert (if)     => (if-zero)    */            \
        x((negate, _if_zero_), (_if_zero_))       /* negate (if-zero)=> (if-zero)    */            \
        x((negate, _if_), (_if_))                 /* negate (if)     => (if)         */            \
        x((negate, plus), (minus))                /* negate +        => -            */            \
        x((negate, minus), (plus))                /* negate -        => +            */            \
        x((negate, one_minus), (invert))          /* negate 1-       => invert       */            \
        x((negate, zero_less), (zero_more))       /* negate 0<       => 0>       OVERFLOW! */      \
        x((negate, zero_less_equal),                                                               \
          (zero_more_equal))                /* negate 0<=      => 0>=      OVERFLOW! */            \
        x((negate, zero_more), (zero_less)) /* negate 0>       => 0<       OVERFLOW! */            \
        x((negate, zero_more_equal),                                                               \
          (zero_less_equal))                           /* negate 0>=      => 0<=      OVERFLOW! */ \
        x((negate, zero_ne), (zero_ne))                /* negate 0<>      => 0<>          */       \
        x((negate, abs), (abs))                        /* negate abs      => abs          */       \
        x((negate, negate), _)                         /* negate negate   =>              */       \
        x((negate, invert), (one_minus))               /* negate invert   => 1-           */       \
        x((negate, squared), (squared))                /* negate squared  => squared      */       \
        x((over, drop), _)                             /* over   drop     =>              */       \
        x((over, nip), (swap))                         /* over   nip      => swap         */       \
        /* x((over, over), (two_dup)) */               /* over   over     => 2dup         */       \
        x((from_r, to_r), _)                           /* r>     >r       =>              */       \
        x((r_from, drop), (r_from_drop))               /* r>     drop     => r>drop       */       \
        x((r_from_drop, to_r), (r_store))              /* r>drop r>       => r!           */       \
        x((rot, minus_rot), _)                         /* rot    rot      => -rot         */       \
        x((rot, rot), (minus_rot))                     /* rot    -rot     =>              */       \
        x((swap, times), (times))                      /* swap *          => *            */       \
        x((swap, plus), (plus))                        /* swap +          => +            */       \
        x((swap, minus), (minus, negate))              /* swap -          => - negate     */       \
        x((swap, less), (more))                        /* swap <          => >            */       \
        x((swap, less_equal), (more_equal))            /* swap <=         => >=           */       \
        x((swap, ne), (ne))                            /* swap <>         => <>           */       \
        x((swap, equal), (equal))                      /* swap =          => =            */       \
        x((swap, more), (less_equal))                  /* swap >          => <            */       \
        x((swap, more_equal), (less_equal))            /* swap >=         => <=           */       \
        x((swap, and), (and))                          /* swap and        => and          */       \
        x((swap, drop), (nip))                         /* swap drop       => nip          */       \
        x((swap, max), (max))                          /* swap max        => max          */       \
        x((swap, min), (min))                          /* swap min        => min          */       \
        x((swap, nip), (drop))                         /* swap nip        => drop         */       \
        x((swap, or), (or))                            /* swap or         => or           */       \
        x((swap, swap), _)                             /* swap swap       =>              */       \
        x((swap, xor), (xor))                          /* swap xor        => xor          */       \
        x((xor, invert), (invert, xor))                /* xor  invert     => invert xor   */       \
        x((one_plus, byte_fetch), (byte_bracket1))     /* 1+   byte@      => byte[1]      */       \
        x((one_plus, c_fetch), (char_bracket1))        /* 1+   c@         => char[1]      */       \
        x((two_plus, byte_fetch), (byte_bracket2))     /* 2+   byte@      => byte[2]      */       \
        x((two_plus, c_fetch), (char_bracket2))        /* 2+   c@         => char[2]      */       \
        x((two_plus, short_fetch), (short_bracket1))   /* 2+   short@     => short[1]     */       \
        x((two_plus, ushort_fetch), (short_bracket1))  /* 2+   ushort@    => ushort[1]    */       \
        x((four_plus, byte_fetch), (byte_bracket4))    /* 4+   byte@      => byte[4]      */       \
        x((four_plus, c_fetch), (char_bracket4))       /* 4+   c@         => char[4]      */       \
        x((four_plus, short_fetch), (short_bracket2))  /* 4+   short@     => short[2]     */       \
        x((four_plus, ushort_fetch), (short_bracket2)) /* 4+   ushort@    => ushort[2]    */       \
        x((four_plus, int_fetch), (int_bracket1))      /* 4+   int@       => int[1]       */       \
        x((four_plus, uint_fetch), (uint_bracket1))    /* 4+   uint@      => uint[1]      */       \
        x((eight_plus, byte_fetch), (byte_bracket4))   /* 8+   byte@      => byte[8]      */       \
        x((eight_plus, c_fetch), (char_bracket4))      /* 8+   c@         => char[8]      */       \
        x((eight_plus, short_fetch), (short_bracket2)) /* 8+   short@     => short[4]     */       \
        x((eight_plus, ushort_fetch), (short_bracket2)) /* 8+   ushort@    => ushort[4]    */      \
        x((eight_plus, int_fetch), (int_bracket1))      /* 8+   int@       => int[2]       */      \
        x((eight_plus, uint_fetch), (uint_bracket1))    /* 8+   uint@      => uint[2]      */      \
        x((SZ_plus, fetch), (cell_bracket1))            /* SZ+  @          => cell[1]      */

#define OPT3_BODY(x, _)               /* note: '_' represents noop       */                        \
    x((r_from, plus, to_r), (r_plus)) /* r> +    >r      => r+           */

#endif /* M4TH_INCLUDE_OPT_MH */
